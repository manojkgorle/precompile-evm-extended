// Code generated
// This file is a generated precompile contract config with stubbed abstract functions.
// The file is generated by a template. Please inspect every code and comment in this file before use.

package rand

import (
  "errors"
  "fmt"
  "math/big"
  "crypto/rand"

  "github.com/ava-labs/subnet-evm/accounts/abi"
  "github.com/ava-labs/subnet-evm/precompile/contract"
  "github.com/ava-labs/subnet-evm/vmerrs"

  _ "embed"

  "github.com/ethereum/go-ethereum/common"
)

const (
  // Gas costs for each function. These are set to 1 by default.
  // You should set a gas cost for each function in your contract.
  // Generally, you should not set gas costs very low as this may cause your network to be vulnerable to DoS attacks.
  // There are some predefined gas costs in contract/utils.go that you can use.
  GenerateRandomNumberGasCost uint64 = 1 /* SET A GAS COST HERE */
)

// CUSTOM CODE STARTS HERE
// Reference imports to suppress errors from unused imports. This code and any unnecessary imports can be removed.
var (
  _ = abi.JSON
  _ = errors.New
  _ = big.NewInt
  _ = vmerrs.ErrOutOfGas
  _ = common.Big0
)

// Singleton StatefulPrecompiledContract and signatures.
var (

  // RandRawABI contains the raw ABI of Rand contract.
  //go:embed contract.abi
  RandRawABI string

  RandABI = contract.ParseABI(RandRawABI)

  RandPrecompile = createRandPrecompile()

  maxValue,_ = new(big.Int).SetString("115792089237316195423570985008687907853269984665640564039457584007913129639935", 10)
)



// UnpackGenerateRandomNumberInput attempts to unpack [input] into the uint32 type argument
// assumes that [input] does not include selector (omits first 4 func signature bytes)
func UnpackGenerateRandomNumberInput(input []byte) (uint32, error) {
  res, err := RandABI.UnpackInput("generateRandomNumber", input)
  if err != nil {
    return 0, err
  }
  unpacked := *abi.ConvertType(res[0], new(uint32)).(*uint32)
  return unpacked, nil
}

// PackGenerateRandomNumber packs [totNum] of type uint32 into the appropriate arguments for generateRandomNumber.
// the packed bytes include selector (first 4 func signature bytes).
// This function is mostly used for tests.
func PackGenerateRandomNumber(totNum uint32) ([]byte, error) {
  return RandABI.Pack("generateRandomNumber", totNum)
}

// PackGenerateRandomNumberOutput attempts to pack given genNum of type []*big.Int
// to conform the ABI outputs.
func PackGenerateRandomNumberOutput(genNum []*big.Int) ([]byte, error) {
  return RandABI.PackOutput("generateRandomNumber", genNum)
}

// UnpackGenerateRandomNumberOutput attempts to unpack given [output] into the []*big.Int type output
// assumes that [output] does not include selector (omits first 4 func signature bytes)
func UnpackGenerateRandomNumberOutput(output []byte) ([]*big.Int, error) {
  res, err := RandABI.Unpack("generateRandomNumber", output)
  if err != nil {
    return nil, err
  }
  unpacked := *abi.ConvertType(res[0], new([]*big.Int)).(*[]*big.Int)
  return unpacked, nil
}

func generateRandomNumber(accessibleState contract.AccessibleState, caller common.Address, addr common.Address, input []byte, suppliedGas uint64, readOnly bool) (ret []byte, remainingGas uint64, err error) {
  if remainingGas, err = contract.DeductGas(suppliedGas, GenerateRandomNumberGasCost); err != nil {
    return nil, 0, err
  }
  // attempts to unpack [input] into the arguments to the GenerateRandomNumberInput.
  // Assumes that [input] does not include selector
  // You can use unpacked [inputStruct] variable in your code
  inputStruct, err := UnpackGenerateRandomNumberInput(input)
  if err != nil {
    return nil, remainingGas, err
  }
  // CUSTOM CODE STARTS HERE
   // CUSTOM CODE OPERATES ON INPUT
   _ = inputStruct
  //inputStruct == totNum
  var outputArray = []*big.Int{}
  for i:=0; i < int(inputStruct); i++ {
    t,err := rand.Int(rand.Reader,maxValue)
    if err != nil {
      outputArray[i] = t
    }
  }
  var output []*big.Int // CUSTOM CODE FOR AN OUTPUT
  output = outputArray
  packedOutput, err := PackGenerateRandomNumberOutput(output)
  if err != nil {
    return nil, remainingGas, err
  }

  // Return the packed output and the remaining gas
  return packedOutput, remainingGas, nil
}

// createRandPrecompile returns a StatefulPrecompiledContract with getters and setters for the precompile.

func createRandPrecompile() contract.StatefulPrecompiledContract {
  var functions []*contract.StatefulPrecompileFunction

  abiFunctionMap := map[string]contract.RunStatefulPrecompileFunc{
    "generateRandomNumber": generateRandomNumber,
  }

  for name, function := range abiFunctionMap {
    method, ok := RandABI.Methods[name]
    if !ok {
      panic(fmt.Errorf("given method (%s) does not exist in the ABI", name))
    }
    functions = append(functions, contract.NewStatefulPrecompileFunction(method.ID, function))
  }
  // Construct the contract with no fallback function.
  statefulContract, err := contract.NewStatefulPrecompileContract(nil, functions)
  if err != nil {
    panic(err)
  }
  return statefulContract
}